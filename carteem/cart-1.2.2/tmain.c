/* Example program to calculate a grid of points for a Gastner-Newman
 * cartogram using the cartogram.c code
 *
 * Written by Mark Newman
 *
 * See http://www.umich.edu/~mejn/ for further details.
 */


#include <stdio.h>
#include <stdlib.h>

#include <teem/meet.h>
#include "tcart.h"


/* The parameter OFFSET specifies a small amount to be added the density in
 * every grid square, as a Fraction of the mean density on the whole
 * lattice.  This prevents negative densities from being generated by
 * numerical errors in the FFTs which can cause problems for the
 * integrator.  If the program is giving weird behavior, particularly at
 * the beginning of a calculation, try increasing this quantity by a factor
 * of 10.
 */

#define OFFSET 0.005


/* Function to read population data into the array rho.  Returns 1 if there
 * was a problem, zero otherwise */
/* GLK: Actually, ha ha no, now its just about adding OFFSET*mean */
int readpop(/* FILE *stream, double **rho */ double *rho, int xsize, int ysize)
{
  int ii;
  int n;
  double mean;
  double sum=0.0;

  /*
    NOTE that reading values from stream, X is the faster axis,
    but when stored in memory, X is the slower axis!
  for (iy=0; iy<ysize; iy++) {
    for (ix=0; ix<xsize; ix++) {
      n = fscanf(stream,"%lf",&rho[ix][iy]);
      if (n!=1) return 1;
      sum += rho[ix][iy];
    }
  }
  */

  for (ii=0; ii<xsize*ysize; ii++) {
    sum += rho[ii];
  }
  mean = sum/(xsize*ysize);
  for (ii=0; ii<xsize*ysize; ii++) {
    rho[ii] += OFFSET*mean;
  }

  return 0;
}


/* Function to make the grid of points */

void creategrid(double *gridxy, int xsize, int ysize)
{
  int ix,iy;
  int i=0;

  for (iy=0; iy<=ysize; iy++) {
    for (ix=0; ix<=xsize; ix++) {
      gridxy[0 + 2*i] = ix;
      gridxy[1 + 2*i] = iy;
      i++;
    }
  }
}


static const char *cartInfo =
  ("heavily Teem-fied cart, "
   "based on http://www-personal.umich.edu/~mejn/cart/.");

int
main(int argc, const char *argv[]) {
  double *gridxy;  // Array for grid points
  cartContext *ctx;

  const char *me = argv[0];
  airArray *mop = airMopNew();
  hestParm *hparm = hestParmNew();
  hestOpt *hopt = NULL;
  Nrrd *nrho;
  char *err, *outName, *rgName;
  unsigned int repeats;

  ctx = cartContextNew();
  airMopAdd(mop, ctx, (airMopper)cartContextNix, airMopAlways);
  airMopAdd(mop, hparm, AIR_CAST(airMopper, hestParmFree), airMopAlways);
  hestOptAdd(&hopt, "i", "rho", airTypeOther, 1, 1, &nrho, NULL,
             "input population data", NULL, NULL, nrrdHestNrrd);
  hestOptAdd(&hopt, "r", "repeats", airTypeUInt, 1, 1, &repeats, "1",
             "number of times to re-run the computation, just so "
             "that it takes longer and provides an easier target "
             "for profiling tools");
  hestOptAdd(&hopt, "g", "gridfile", airTypeString, 1, 1, &rgName, "",
             "if given a filename with this option, the reference grid "
             "(with no displacement from the cartogram) is saved here, "
             "to simplify inspection of cartogram results. ");
  hestOptAdd(&hopt, "v", "verbosity", airTypeInt, 1, 1, &(ctx->verbosity), "0",
             "level of printf verbosity");
  hestOptAdd(&hopt, "s", NULL, airTypeInt, 0, 0, &(ctx->savesnaps), NULL,
             "save snapshots of the density computed via fft");
  hestOptAdd(&hopt, "o", "fname", airTypeString, 1, 1, &outName, NULL,
             "output filename");
  hestParseOrDie(hopt, argc-1, argv+1, hparm,
                 me, cartInfo, AIR_TRUE, AIR_TRUE, AIR_TRUE);
  airMopAdd(mop, hopt, AIR_CAST(airMopper, hestOptFree), airMopAlways);
  airMopAdd(mop, hopt, AIR_CAST(airMopper, hestParseFree), airMopAlways);

  if (!( 2 == nrho->dim && nrrdTypeDouble == nrho->type )) {
    fprintf(stderr, "%s: want 2-D array of doubles (not %u-D of %s)\n", me,
            nrho->dim, airEnumStr(nrrdType, nrho->type));
    airMopError(mop);
    return 1;
  }
  double *rho = (double*)nrho->data;
  int xsize = (int)nrho->axis[0].size;
  int ysize = (int)nrho->axis[1].size;

  /* Allocate space for the cartogram code to use */
  cart_makews(ctx,xsize,ysize);
  fprintf(stderr, "%s: x,y size = %d %d\n", me, xsize, ysize);

  /* add OFFSET*mean */
  readpop(rho,xsize,ysize);
  cart_forward(ctx,rho,xsize,ysize);

  /* Create the grid of points */
  Nrrd *ngridxy = nrrdNew();
  airMopAdd(mop, ngridxy, (airMopper)nrrdNuke, airMopAlways);
  size_t gsize[3] = {2, xsize+1, ysize+1};
  if (nrrdMaybeAlloc_nva(ngridxy, nrrdTypeDouble, 3, gsize)) {
    airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
    fprintf(stderr, "%s: problem allocating grid: %s", me, err);
    airMopError(mop);
    exit(7);
  }
  gridxy = (double*)(ngridxy->data);

  /* Make the cartogram */
  unsigned int repIdx;
  for (repIdx=0; repIdx<repeats; repIdx++) {
    if (repeats > 1) {
      printf("%s: %u/%u begins ... \n", me, repIdx, repeats);
    }
    creategrid(gridxy,xsize,ysize);
    if (!repIdx && strlen(rgName)) {
      if (nrrdSave(rgName, ngridxy, NULL)) {
        airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
        fprintf(stderr, "%s: problem saving reference grid: %s", me, err);
        airMopError(mop);
        exit(7);
      }
    }
    double time0 = airTime();
    cart_makecart(ctx,gridxy,(xsize+1)*(ysize+1),xsize,ysize,0.0);
    double time1 = airTime();
    if (repeats > 1) {
      printf("%s:              ... %g secs for %u/%u\n", me, time1-time0, repIdx, repeats);
    } else {
      printf("%s:              ... %g secs\n", me, time1-time0);
    }
  }

  if (nrrdSave(outName, ngridxy, NULL)) {
    airMopAdd(mop, err = biffGetDone(NRRD), airFree, airMopAlways);
    fprintf(stderr, "%s: problem saving output grid: %s", me, err);
    airMopError(mop);
    exit(7);
  }

  /* Free up the allocated space */
  cart_freews(ctx,xsize,ysize);

  /* cleanup */
  airMopOkay(mop);
  return 0;
}
